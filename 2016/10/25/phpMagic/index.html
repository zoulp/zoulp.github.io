
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>PHP之十六个魔术方法详解 | Lpeng Zou</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Lpeng Zou">
    

    
    <meta name="description" content="PHP之十六个魔术方法详解这是摘抄的，不过很好懂对于初级程序员来说可以读一下">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP之十六个魔术方法详解">
<meta property="og:url" content="http://zoulp.github.io/2016/10/25/phpMagic/index.html">
<meta property="og:site_name" content="Lpeng Zou">
<meta property="og:description" content="PHP之十六个魔术方法详解这是摘抄的，不过很好懂对于初级程序员来说可以读一下">
<meta property="og:updated_time" content="2016-10-25T11:03:29.165Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHP之十六个魔术方法详解">
<meta name="twitter:description" content="PHP之十六个魔术方法详解这是摘抄的，不过很好懂对于初级程序员来说可以读一下">

    
    <link rel="alternative" href="/atom.xml" title="Lpeng Zou" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Lpeng Zou" title="Lpeng Zou"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Lpeng Zou">Lpeng Zou</a></h1>
				<h2 class="blog-motto">kevin_zo@sina</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">about</a></li>
					
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/25/phpMagic/" title="PHP之十六个魔术方法详解" itemprop="url">PHP之十六个魔术方法详解</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lpeng Zou" target="_blank" itemprop="author">Lpeng Zou</a>
		
  <p class="article-time">
    <time datetime="2016-10-25T09:02:07.000Z" itemprop="datePublished"> 发表于 2016-10-25</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#construct-，类的构造函数"><span class="toc-number">1.</span> <span class="toc-text">__construct()，类的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#destruct-，类的析构函数"><span class="toc-number">2.</span> <span class="toc-text">__destruct()，类的析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-，在对象中调用一个不可访问方法时调用。"><span class="toc-number">3.</span> <span class="toc-text">__call()，在对象中调用一个不可访问方法时调用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#callStatic-，用静态方式中调用一个不可访问方法时调用"><span class="toc-number">4.</span> <span class="toc-text">__callStatic()，用静态方式中调用一个不可访问方法时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-，获得一个类的成员变量时调用"><span class="toc-number">5.</span> <span class="toc-text">__get()，获得一个类的成员变量时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-，设置一个类的成员变量时调用"><span class="toc-number">6.</span> <span class="toc-text">__set()，设置一个类的成员变量时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isset-，当对不可访问属性调用isset-或empty-时调用"><span class="toc-number">7.</span> <span class="toc-text">__isset()，当对不可访问属性调用isset()或empty()时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unset-，当对不可访问属性调用unset-时被调用。"><span class="toc-number">8.</span> <span class="toc-text">__unset()，当对不可访问属性调用unset()时被调用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-，执行serialize-时，先会调用这个函数"><span class="toc-number">9.</span> <span class="toc-text">__sleep()，执行serialize()时，先会调用这个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wakeup-，执行unserialize-时，先会调用这个函数"><span class="toc-number">10.</span> <span class="toc-text">__wakeup()，执行unserialize()时，先会调用这个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toString-，类被当成字符串时的回应方法"><span class="toc-number">11.</span> <span class="toc-text">__toString()，类被当成字符串时的回应方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#invoke-，调用函数的方式调用一个对象时的回应方法"><span class="toc-number">12.</span> <span class="toc-text">__invoke()，调用函数的方式调用一个对象时的回应方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-state-，调用var-export-导出类时，此静态方法会被调用。"><span class="toc-number">13.</span> <span class="toc-text">__set_state()，调用var_export()导出类时，此静态方法会被调用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clone-，当对象复制完成时调用"><span class="toc-number">14.</span> <span class="toc-text">__clone()，当对象复制完成时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#autoload-，尝试加载未定义的类"><span class="toc-number">15.</span> <span class="toc-text">__autoload()，尝试加载未定义的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debugInfo-，打印所需调试信息"><span class="toc-number">16.</span> <span class="toc-text">__debugInfo()，打印所需调试信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">17.</span> <span class="toc-text">总结</span></a></li></ol>
		
		</div>
		
		<p><em>PHP之十六个魔术方法详解</em><br><em>这是摘抄的，不过很好懂</em><br><em>对于初级程序员来说可以读一下</em><br><a id="more"></a><br><a href="https://segmentfault.com/a/1190000007250604" target="_blank" rel="external">点击原文：PHP之十六个魔术方法详解</a></p>
<ul>
<li><p><strong> Magic methods </strong><br>PHP中把以两个下划线__开头的方法称为魔术方法(Magic methods)，<br>这些方法在PHP中充当了举足轻重的作用。<br>魔术方法包括：</p>
</li>
<li><p><strong>  __construct()</strong>，类的构造函数</p>
</li>
<li><strong> __destruct()</strong>，类的析构函数</li>
<li><strong> __call()</strong>，在对象中调用一个不可访问方法时调用</li>
<li><strong>  __callStatic()</strong>，用静态方式中调用一个不可访问方法时调用</li>
<li><strong> __get()</strong>，获得一个类的成员变量时调用</li>
<li><strong>  __set()</strong>，设置一个类的成员变量时调用</li>
<li><strong>  __isset()</strong>，当对不可访问属性调用isset()或empty()时调用</li>
<li><strong> __unset()</strong>，当对不可访问属性调用unset()时被调用。</li>
<li><strong>  __sleep()</strong>，执行serialize()时，先会调用这个函数</li>
<li><strong> __wakeup()</strong>，执行unserialize()时，先会调用这个函数</li>
<li><strong> __toString()</strong>，类被当成字符串时的回应方法</li>
<li><strong>  __invoke()</strong>，调用函数的方式调用一个对象时的回应方法</li>
<li><strong>  __set_state()</strong>，调用var_export()导出类时，此静态方法会被调用。</li>
<li><strong>  __clone()</strong>，当对象复制完成时调用</li>
<li><strong> __autoload()</strong>，尝试加载未定义的类</li>
<li><strong> __debugInfo()</strong>，打印所需调试信息</li>
</ul>
<p>范例<br>下面让我们以实例的形式向大家讲解下这几个魔术方法时如何使用的。</p>
<h2 id="construct-，类的构造函数"><a href="#construct-，类的构造函数" class="headerlink" title="__construct()，类的构造函数"></a>__construct()，类的构造函数</h2><p>php中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。</p>
<p>1、 构造方法的作用</p>
<p>通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。</p>
<p>2、 构造方法的在类中的声明格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function __constrct([参数列表])&#123;</div><div class="line"></div><div class="line">    方法体 //通常用来对成员属性进行初始化赋值</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、 在类中声明构造方法需要注意的事项</p>
<pre><code>*1)在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。*

*2)构造方法名称是以两个下画线开始的__construct()*
</code></pre><p>下面是它的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    class Person</div><div class="line">    &#123;                                                                      </div><div class="line">            public $name;        </div><div class="line">            public $age;        </div><div class="line">            public $sex;        </div><div class="line">                                                                 </div><div class="line">        /**</div><div class="line">         * 显示声明一个构造方法且带参数</div><div class="line">         */                                                                                       </div><div class="line">        public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</div><div class="line">        &#123;      </div><div class="line">            $this-&gt;name = $name;</div><div class="line">            $this-&gt;sex = $sex;</div><div class="line">            $this-&gt;age = $age;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        /**</div><div class="line">         * say 方法</div><div class="line">         */</div><div class="line">        public function say()</div><div class="line">        &#123; </div><div class="line">            echo &quot;我叫：&quot; . $this-&gt;name . &quot;，性别：&quot; . $this-&gt;sex . &quot;，年龄：&quot; . $this-&gt;age;</div><div class="line">        &#125;   </div><div class="line">                                                                                           </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">创建对象$Person1且不带任参数</div><div class="line">$Person1 = new Person();</div><div class="line">echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27</div><div class="line">创建对象$Person2且带参数“小明”</div><div class="line"></div><div class="line">$Person2 = new Person(&quot;小明&quot;);</div><div class="line">echo $Person2-&gt;say(); //输出：我叫：张三，性别：男，年龄：27</div><div class="line">创建对象$Person3且带三个参数</div><div class="line"></div><div class="line">$Person3 = new Person(&quot;李四&quot;,&quot;男&quot;,25);</div><div class="line">echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25</div></pre></td></tr></table></figure>
<h2 id="destruct-，类的析构函数"><a href="#destruct-，类的析构函数" class="headerlink" title="__destruct()，类的析构函数"></a>__destruct()，类的析构函数</h2><p>通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。</p>
<p>析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。</p>
<p>析构方法是PHP5才引进的新内容。</p>
<p>析造方法的声明格式与构造方法 <strong>construct() 比较类似，也是以两个下划线开始的方法 </strong>destruct() ，这种析构方法名称也是固定的。</p>
<p>1、 析构方法的声明格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function __destruct()</div><div class="line">&#123;</div><div class="line"> //方法体</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：析构函数不能带有任何参数。</p>
<p>2、 析构方法的作用</p>
<p>一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。<br>举例演示，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person&#123;     </div><div class="line">                                                        </div><div class="line">    public $name;         </div><div class="line">    public $age;         </div><div class="line">    public $sex;         </div><div class="line">                                                                    </div><div class="line">    public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</div><div class="line">    &#123;   </div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * say 说话方法</div><div class="line">     */</div><div class="line">    public function say()</div><div class="line">    &#123;  </div><div class="line">        echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age;</div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 声明一个析构方法</div><div class="line">     */</div><div class="line">    public function __destruct()</div><div class="line">    &#123;</div><div class="line">            echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$Person = new Person(&quot;小明&quot;);</div><div class="line">unset($Person); //销毁上面创建的对象$Person</div></pre></td></tr></table></figure></p>
<p>上面的程序运行时输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我觉得我还可以再抢救一下，我的名字叫小明</div></pre></td></tr></table></figure></p>
<h2 id="call-，在对象中调用一个不可访问方法时调用。"><a href="#call-，在对象中调用一个不可访问方法时调用。" class="headerlink" title="__call()，在对象中调用一个不可访问方法时调用。"></a>__call()，在对象中调用一个不可访问方法时调用。</h2><p>该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。</p>
<p>1、 __call() 方法的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function __call(string $function_name, array $arguments)</div><div class="line">&#123;</div><div class="line">    // 方法体</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、 __call() 方法的作用：</p>
<p>为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。</p>
<p>该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。<br>请参考如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;                             </div><div class="line">    function say()</div><div class="line">    &#123;  </div><div class="line">                              </div><div class="line">           echo &quot;Hello, world!&lt;br&gt;&quot;; </div><div class="line">    &#125;      </div><div class="line">        </div><div class="line">    /**</div><div class="line">     * 声明此方法用来处理调用对象中不存在的方法</div><div class="line">     */</div><div class="line">    function __call($funName, $arguments)</div><div class="line">    &#123; </div><div class="line">          echo &quot;你所调用的函数：&quot; . $funName . &quot;(参数：&quot; ;  // 输出调用不存在的方法名</div><div class="line">          print_r($arguments); // 输出调用不存在的方法时的参数列表</div><div class="line">          echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行                      </div><div class="line">    &#125;                                          </div><div class="line">&#125;</div><div class="line">$Person = new Person();            </div><div class="line">$Person-&gt;run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法</div><div class="line">$Person-&gt;eat(&quot;小明&quot;, &quot;苹果&quot;);             </div><div class="line">$Person-&gt;say();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>运行结果：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！</div><div class="line"></div><div class="line">你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！</div><div class="line"></div><div class="line">Hello, world!</div></pre></td></tr></table></figure>
<h2 id="callStatic-，用静态方式中调用一个不可访问方法时调用"><a href="#callStatic-，用静态方式中调用一个不可访问方法时调用" class="headerlink" title="__callStatic()，用静态方式中调用一个不可访问方法时调用"></a>__callStatic()，用静态方式中调用一个不可访问方法时调用</h2><p>此方法与上面所说的 <strong>call() 功能除了 </strong>callStatic() 是未静态方法准备的之外，其它都是一样的。</p>
<p>请看下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    function say()</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        echo &quot;Hello, world!&lt;br&gt;&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 声明此方法用来处理调用对象中不存在的方法</div><div class="line">     */</div><div class="line">    public static function __callStatic($funName, $arguments)</div><div class="line">    &#123;</div><div class="line">        echo &quot;你所调用的静态方法：&quot; . $funName . &quot;(参数：&quot; ;  // 输出调用不存在的方法名</div><div class="line">        print_r($arguments); // 输出调用不存在的方法时的参数列表</div><div class="line">        echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$Person = new Person();</div><div class="line">$Person::run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法</div><div class="line">$Person::eat(&quot;小明&quot;, &quot;苹果&quot;);</div><div class="line">$Person-&gt;say();</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！</div><div class="line">你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！</div><div class="line">Hello, world!</div></pre></td></tr></table></figure></p>
<h2 id="get-，获得一个类的成员变量时调用"><a href="#get-，获得一个类的成员变量时调用" class="headerlink" title="__get()，获得一个类的成员变量时调用"></a>__get()，获得一个类的成员变量时调用</h2><p>在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。</p>
<p>魔术方法<strong>get()的作用<br>在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。<br>我们通过下面的 </strong>get() 的实例来更进一步的连接它吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    private $name;</div><div class="line">    private $age;</div><div class="line"></div><div class="line">    function __construct($name=&quot;&quot;, $age=1)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age = $age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理</div><div class="line">     * @param $propertyName</div><div class="line">     *</div><div class="line">     * @return int</div><div class="line">     */</div><div class="line">    public function __get($propertyName)</div><div class="line">    &#123;   </div><div class="line">        if ($propertyName == &quot;age&quot;) &#123;</div><div class="line">            if ($this-&gt;age &gt; 30) &#123;</div><div class="line">                return $this-&gt;age - 10;</div><div class="line">            &#125; else &#123;</div><div class="line">                return $this-&gt;$propertyName;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            return $this-&gt;$propertyName;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$Person = new Person(&quot;小明&quot;, 60);   // 通过Person类实例化的对象，并通过构造方法为属性赋初值</div><div class="line">echo &quot;姓名：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;;   // 直接访问私有属性name，自动调用了__get()方法可以间接获取</div><div class="line">echo &quot;年龄：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;;    // 自动调用了__get()方法，根据对象本身的情况会返回不同的值</div><div class="line">&gt; 运行结果：</div><div class="line"></div><div class="line">姓名：小明</div><div class="line">年龄：50</div></pre></td></tr></table></figure></p>
<h2 id="set-，设置一个类的成员变量时调用"><a href="#set-，设置一个类的成员变量时调用" class="headerlink" title="__set()，设置一个类的成员变量时调用"></a>__set()，设置一个类的成员变量时调用</h2><p><strong>set() 的作用：
</strong>set( $property, $value )，方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。</p>
<p>请看下面的演示代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    private $name;</div><div class="line">    private $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值</div><div class="line">     * @param $property</div><div class="line">     * @param $value</div><div class="line">     */</div><div class="line">    public function __set($property, $value) &#123;</div><div class="line">        if ($property==&quot;age&quot;)</div><div class="line">        &#123;</div><div class="line">            if ($value &gt; 150 || $value &lt; 0) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        $this-&gt;$property = $value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 在类中声明说话的方法，将所有的私有属性说出</div><div class="line">     */</div><div class="line">    public function say()&#123;</div><div class="line">        echo &quot;我叫&quot;.$this-&gt;name.&quot;，今年&quot;.$this-&gt;age.&quot;岁了&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$Person=new Person(&quot;小明&quot;, 25); //注意，初始值将被下面所改变</div><div class="line">//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数</div><div class="line">$Person-&gt;name = &quot;小红&quot;;     //赋值成功。如果没有__set()，则出错。</div><div class="line">//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数</div><div class="line">$Person-&gt;age = 16; //赋值成功</div><div class="line">$Person-&gt;age = 160; //160是一个非法值，赋值失效</div><div class="line">$Person-&gt;say();  //输出：我叫小红，今年16岁了</div></pre></td></tr></table></figure></p>
<blockquote>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我叫小红，今年16岁了</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="isset-，当对不可访问属性调用isset-或empty-时调用"><a href="#isset-，当对不可访问属性调用isset-或empty-时调用" class="headerlink" title="__isset()，当对不可访问属性调用isset()或empty()时调用"></a>__isset()，当对不可访问属性调用isset()或empty()时调用</h2><p>在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。</p>
<p>那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？</p>
<p>分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个<strong>isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的</strong>isset()方法了帮我们完成这样的操作。</p>
<p><strong>isset()的作用：当对不可访问属性调用 isset() 或 empty() 时，</strong>isset() 会被调用。<br>请看下面代码演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    private $name;</div><div class="line">    private $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param $content</div><div class="line">     *</div><div class="line">     * @return bool</div><div class="line">     */</div><div class="line">    public function __isset($content) &#123;</div><div class="line">        echo &quot;当在类外部使用isset()函数测定私有成员&#123;$content&#125;时，自动调用&lt;br&gt;&quot;;</div><div class="line">        echo  isset($this-&gt;$content);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$person = new Person(&quot;小明&quot;, 25); // 初始赋值</div><div class="line">echo isset($person-&gt;sex),&quot;&lt;br&gt;&quot;;</div><div class="line">echo isset($person-&gt;name),&quot;&lt;br&gt;&quot;;</div><div class="line">echo isset($person-&gt;age),&quot;&lt;br&gt;&quot;;</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// public 可以 isset()</div><div class="line">当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo</div><div class="line">// __isset() 内第二个echo</div><div class="line">当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo</div><div class="line">// __isset() 内第二个echo</div></pre></td></tr></table></figure></p>
<h2 id="unset-，当对不可访问属性调用unset-时被调用。"><a href="#unset-，当对不可访问属性调用unset-时被调用。" class="headerlink" title="__unset()，当对不可访问属性调用unset()时被调用。"></a>__unset()，当对不可访问属性调用unset()时被调用。</h2><p>看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。</p>
<p>那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？</p>
<p>这里自然也是分两种情况：</p>
<p>1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。</p>
<p>2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。</p>
<p>虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上<strong>unset()<br>这个方法，就可以在对象的外部去删除对象的私有成员属性了。<br>在对象里面加上了</strong>unset()这个方法之后，<br>在对象外部使用“unset()”函数删除对象内部的私有成员属性时，<br>对象会自动调用__unset()函数来帮我们删除对象内部的私有成员属性。</p>
<p>请看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    private $name;</div><div class="line">    private $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param $content</div><div class="line">     *</div><div class="line">     * @return bool</div><div class="line">     */</div><div class="line">    public function __unset($content) &#123;</div><div class="line">        echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;;</div><div class="line">        echo  isset($this-&gt;$content);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$person = new Person(&quot;小明&quot;, 25); // 初始赋值</div><div class="line">unset($person-&gt;sex);</div><div class="line">unset($person-&gt;name);</div><div class="line">unset($person-&gt;age);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">当在类外部使用unset()函数来删除私有成员时自动调用的</div><div class="line">当在类外部使用unset()函数来删除私有成员时自动调用的</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="sleep-，执行serialize-时，先会调用这个函数"><a href="#sleep-，执行serialize-时，先会调用这个函数" class="headerlink" title="__sleep()，执行serialize()时，先会调用这个函数"></a>__sleep()，执行serialize()时，先会调用这个函数</h2><p>serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。</p>
<p>此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</p>
<p>如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。</p>
<p>注意：</p>
<p>__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。<br>作用：</p>
<p>__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。<br>具体请参考如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    public $name;</div><div class="line">    public $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @return array</div><div class="line">     */</div><div class="line">    public function __sleep() &#123;</div><div class="line">        echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;</div><div class="line">        $this-&gt;name = base64_encode($this-&gt;name);</div><div class="line">        return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</div><div class="line">echo serialize($person);</div><div class="line">echo &apos;&lt;br/&gt;&apos;;</div></pre></td></tr></table></figure></p>
<p>代码&gt; 运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">当在类外部使用serialize()时会调用这里的__sleep()方法</div><div class="line">O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="wakeup-，执行unserialize-时，先会调用这个函数"><a href="#wakeup-，执行unserialize-时，先会调用这个函数" class="headerlink" title="__wakeup()，执行unserialize()时，先会调用这个函数"></a>__wakeup()，执行unserialize()时，先会调用这个函数</h2><p>如果说 <strong>sleep() 是白的，那么 </strong>wakeup() 就是黑的了。</p>
<p>那么为什么呢？</p>
<p>因为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">与之相反，`unserialize()` 会检查是否存在一个 `__wakeup()` 方法。如果存在，则会先调用 `__wakeup` 方法，预先准备对象需要的资源。</div><div class="line">作用：</div></pre></td></tr></table></figure></p>
<p>__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。<br>还是看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    public $name;</div><div class="line">    public $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @return array</div><div class="line">     */</div><div class="line">    public function __sleep() &#123;</div><div class="line">        echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;</div><div class="line">        $this-&gt;name = base64_encode($this-&gt;name);</div><div class="line">        return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * __wakeup</div><div class="line">     */</div><div class="line">    public function __wakeup() &#123;</div><div class="line">        echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;;</div><div class="line">        $this-&gt;name = 2;</div><div class="line">        $this-&gt;sex = &apos;男&apos;;</div><div class="line">        // 这里不需要返回数组</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</div><div class="line">var_dump(serialize($person));</div><div class="line">var_dump(unserialize(serialize($person)));</div></pre></td></tr></table></figure></p>
<blockquote>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">当在类外部使用serialize()时会调用这里的__sleep()方法</div><div class="line">string(58) &quot;O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;&quot; 当在类外部使用serialize()</div><div class="line">时会调用这里的__sleep()方法</div><div class="line">当在类外部使用unserialize()时会调用这里的__wakeup()方法</div><div class="line">object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="toString-，类被当成字符串时的回应方法"><a href="#toString-，类被当成字符串时的回应方法" class="headerlink" title="__toString()，类被当成字符串时的回应方法"></a>__toString()，类被当成字符串时的回应方法</h2><p>作用：</p>
<p><strong>toString() 方法用于一个类被当成字符串时应怎样回应。例如 <code>echo $obj;</code> 应该显示些什么。<br>注意：<br>此方法必须返回一个字符串，否则将发出一条 <code>E_RECOVERABLE_ERROR</code> 级别的致命错误。<br>警告：<br>不能在 </strong>toString() 方法中抛出异常。这么做会导致致命错误。<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    public $name;</div><div class="line">    public $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function __toString()</div><div class="line">    &#123;</div><div class="line">        return  &apos;go go go&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</div><div class="line">echo $person;</div></pre></td></tr></table></figure></p>
<p>结果：</p>
<p>go go go<br>那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下：</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    public $name;</div><div class="line">    public $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</div><div class="line">echo $person;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Catchable fatal error: Object of class Person could not be converted to string in D:\phpStudy\WWW\test\index.php on line 18</div></pre></td></tr></table></figure></p>
<p>很明显，页面报了一个致命错误，这是语法所不允许的。</p>
<h2 id="invoke-，调用函数的方式调用一个对象时的回应方法"><a href="#invoke-，调用函数的方式调用一个对象时的回应方法" class="headerlink" title="__invoke()，调用函数的方式调用一个对象时的回应方法"></a>__invoke()，调用函数的方式调用一个对象时的回应方法</h2><p>作用：</p>
<p>当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。<br>注意：</p>
<p>本特性只在 PHP 5.3.0 及以上版本有效。<br>直接上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    public $name;</div><div class="line">    public $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function __invoke() &#123;</div><div class="line">        echo &apos;这可是一个对象哦&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</div><div class="line">$person();</div></pre></td></tr></table></figure></p>
<p>查看&gt; 运行结果：</p>
<p>这可是一个对象哦<br>当然，如果你执意要将对象当函数方法使用，那么会得到下面结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Fatal error: Function name must be a string in D:\phpStudy\WWW\test\index.php on line 18</div></pre></td></tr></table></figure></p>
<h2 id="set-state-，调用var-export-导出类时，此静态方法会被调用。"><a href="#set-state-，调用var-export-导出类时，此静态方法会被调用。" class="headerlink" title="__set_state()，调用var_export()导出类时，此静态方法会被调用。"></a>__set_state()，调用var_export()导出类时，此静态方法会被调用。</h2><p>作用：</p>
<p>自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。<br>参数：</p>
<p>本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。<br>下面我们先来看看在没有加 __set_state() 情况按下，代码及运行结果如何：</p>
<p>上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    public $name;</div><div class="line">    public $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</div><div class="line">var_export($person);</div></pre></td></tr></table></figure></p>
<p>看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小明&apos;, &apos;age&apos; =&gt; 25, ))</div></pre></td></tr></table></figure></p>
<p>很明显，将对象中的属性都打印出来了<br>加了 __set_state() 之后：<br>继续上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    public $name;</div><div class="line">    public $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function __set_state($an_array)</div><div class="line">    &#123;</div><div class="line">        $a = new Person();</div><div class="line">        $a-&gt;name = $an_array[&apos;name&apos;];</div><div class="line">        return $a;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</div><div class="line">$person-&gt;name = &apos;小红&apos;;</div><div class="line">var_export($person);</div></pre></td></tr></table></figure></p>
<p>继续看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小红&apos;, &apos;age&apos; =&gt; 25, ))</div></pre></td></tr></table></figure></p>
<h2 id="clone-，当对象复制完成时调用"><a href="#clone-，当对象复制完成时调用" class="headerlink" title="__clone()，当对象复制完成时调用"></a>__clone()，当对象复制完成时调用</h2><p>在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。</p>
<p>作用：</p>
<p>对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 <strong>clone() 方法）。对象中的 </strong>clone() 方法不能被直接调用。<br>语法：</p>
<p>$copy_of_object = clone $object;<br>注意：</p>
<p>当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。</p>
<p>当复制完成时，如果定义了 <strong>clone() 方法，则新创建的对象（复制生成的对象）中的 </strong>clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。<br>看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;</div><div class="line">    public $sex;</div><div class="line">    public $name;</div><div class="line">    public $age;</div><div class="line"></div><div class="line">    public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function __clone()</div><div class="line">    &#123;</div><div class="line">        echo __METHOD__.&quot;你正在克隆对象&lt;br&gt;&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</div><div class="line">$person2 = clone $person;</div><div class="line"></div><div class="line">var_dump(&apos;persion1:&apos;);</div><div class="line">var_dump($person);</div><div class="line">echo &apos;&lt;br&gt;&apos;;</div><div class="line">var_dump(&apos;persion2:&apos;);</div><div class="line">var_dump($person2);</div></pre></td></tr></table></figure></p>
<p>看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person::__clone你正在克隆对象</div><div class="line">string(9) &quot;persion1:&quot; object(Person)#1 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125; </div><div class="line">string(9) &quot;persion2:&quot; object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125;</div><div class="line">克隆成功。</div></pre></td></tr></table></figure></p>
<h2 id="autoload-，尝试加载未定义的类"><a href="#autoload-，尝试加载未定义的类" class="headerlink" title="__autoload()，尝试加载未定义的类"></a>__autoload()，尝试加载未定义的类</h2><p>作用：</p>
<p>你可以通过定义这个函数来启用类的自动加载。<br>在魔术函数 __autoload() 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。</p>
<p>但是有了 __autoload() 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。</p>
<p>还是通过例子来看看吧：</p>
<p>先看看以往的方式：</p>
<p>/** </p>
<ul>
<li>文件non_autoload.php<br>*/ </li>
</ul>
<p>require_once(‘project/class/A.php’);<br>require_once(‘project/class/B.php’);<br>require_once(‘project/class/C.php’);  </p>
<p>if (条件A) {<br>    $a = new A();<br>    $b = new B();<br>    $c = new C();<br>    // … 业务逻辑<br>} else if (条件B) {<br>    $a = newA();<br>    $b = new B();<br>    // … 业务逻辑<br>}<br>看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。</p>
<p>那么如果使用 __autoload() 方式呢？</p>
<p>/** </p>
<ul>
<li>文件autoload_demo.php<br>*/<br>function  __autoload($className) {<br> $filePath = “project/class/{$className}.php”;<br> if (is_readable($filePath)) {  <pre><code>require($filePath);  
</code></pre> }<br>}  </li>
</ul>
<p>if (条件A) {<br>    $a = new A();<br>    $b = new B();<br>    $c = new C();<br>    // … 业务逻辑<br>} else if (条件B) {<br>    $a = newA();<br>    $b = new B();<br>    // … 业务逻辑<br>}<br>ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。</p>
<p>再来看看这里的效率如何，我们分析下：</p>
<p>当php引擎第一次使用类A，但是找不到时，会自动调用 <strong>autoload 方法，并将类名“A”作为参数传入。所以，我们在 </strong>autoload() 中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。</p>
<p><em>注意：</em></p>
<p>这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，<br>将不会调用__autoload，而是直接使用内存中的类A，不会导致多次包含。</p>
<p><em>扩展：</em></p>
<p>其实php发展到今天，已经有将 <code>spl_autoload_register</code> — 注册给定的函数作为 __autoload 的实现了，<br>但是这个不在啊本文讲解之内，有兴趣可以自行看手册。</p>
<h2 id="debugInfo-，打印所需调试信息"><a href="#debugInfo-，打印所需调试信息" class="headerlink" title="__debugInfo()，打印所需调试信息"></a>__debugInfo()，打印所需调试信息</h2><p>注意：<br>该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。<br>看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class C &#123;</div><div class="line">    private $prop;</div><div class="line"></div><div class="line">    public function __construct($val) &#123;</div><div class="line">        $this-&gt;prop = $val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @return array</div><div class="line">     */</div><div class="line">    public function __debugInfo() &#123;</div><div class="line">        return [</div><div class="line">            &apos;propSquared&apos; =&gt; $this-&gt;prop ** 2,</div><div class="line">        ];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var_dump(new C(42));</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object(C)#1 (1) &#123; [&quot;propSquared&quot;]=&gt; int(1764) &#125;</div></pre></td></tr></table></figure></p>
<p>再次注意：</p>
<p>这里的 <code>**</code> 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册</p>
<ul>
<li><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>以上就是PHP中我了解到的魔术方法了，常用的包括 <strong>set() </strong>get() __autoload() 等应该熟悉，其他的了解也没有关系，毕竟知识不怕多嘛。</li>
</ul>
<p>好了，有兴趣的或者我这里没有说明白的，可以参考啊官方文档。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/php/">php</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/php/">php</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://zoulp.github.io/2016/10/25/phpMagic/" data-title="PHP之十六个魔术方法详解 | Lpeng Zou" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/10/24/jsReg/"  title="js正则用法详解">
 <strong>下一篇：</strong><br/> 
 <span>js正则用法详解
</span>
</a>
</div>

</nav>

	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#construct-，类的构造函数"><span class="toc-number">1.</span> <span class="toc-text">__construct()，类的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#destruct-，类的析构函数"><span class="toc-number">2.</span> <span class="toc-text">__destruct()，类的析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-，在对象中调用一个不可访问方法时调用。"><span class="toc-number">3.</span> <span class="toc-text">__call()，在对象中调用一个不可访问方法时调用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#callStatic-，用静态方式中调用一个不可访问方法时调用"><span class="toc-number">4.</span> <span class="toc-text">__callStatic()，用静态方式中调用一个不可访问方法时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-，获得一个类的成员变量时调用"><span class="toc-number">5.</span> <span class="toc-text">__get()，获得一个类的成员变量时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-，设置一个类的成员变量时调用"><span class="toc-number">6.</span> <span class="toc-text">__set()，设置一个类的成员变量时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isset-，当对不可访问属性调用isset-或empty-时调用"><span class="toc-number">7.</span> <span class="toc-text">__isset()，当对不可访问属性调用isset()或empty()时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unset-，当对不可访问属性调用unset-时被调用。"><span class="toc-number">8.</span> <span class="toc-text">__unset()，当对不可访问属性调用unset()时被调用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-，执行serialize-时，先会调用这个函数"><span class="toc-number">9.</span> <span class="toc-text">__sleep()，执行serialize()时，先会调用这个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wakeup-，执行unserialize-时，先会调用这个函数"><span class="toc-number">10.</span> <span class="toc-text">__wakeup()，执行unserialize()时，先会调用这个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toString-，类被当成字符串时的回应方法"><span class="toc-number">11.</span> <span class="toc-text">__toString()，类被当成字符串时的回应方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#invoke-，调用函数的方式调用一个对象时的回应方法"><span class="toc-number">12.</span> <span class="toc-text">__invoke()，调用函数的方式调用一个对象时的回应方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-state-，调用var-export-导出类时，此静态方法会被调用。"><span class="toc-number">13.</span> <span class="toc-text">__set_state()，调用var_export()导出类时，此静态方法会被调用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clone-，当对象复制完成时调用"><span class="toc-number">14.</span> <span class="toc-text">__clone()，当对象复制完成时调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#autoload-，尝试加载未定义的类"><span class="toc-number">15.</span> <span class="toc-text">__autoload()，尝试加载未定义的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debugInfo-，打印所需调试信息"><span class="toc-number">16.</span> <span class="toc-text">__debugInfo()，打印所需调试信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">17.</span> <span class="toc-text">总结</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/mysql/" title="mysql">mysql<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/other/" title="other">other<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/php/" title="php">php<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/redis/" title="redis">redis<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/web/" title="web">web<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/web/" title="web">web<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/other/" title="other">other<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/php/" title="php">php<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/http/" title="http">http<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/css/" title="css">css<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/session/" title="session">session<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/redis/" title="redis">redis<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/vim/" title="vim">vim<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://zoulp.github.io" target="_blank" title="Lpeng Zou&#39;s Blog">Lpeng Zou&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 回头看看自己的路.我已竭尽全力 <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/http://weibo.com/p/1005055982977300" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Lpeng Zou">Lpeng Zou</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
