
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>PHP之十六个魔术方法详解 | Lpeng Zou</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Lpeng Zou">
    

    
    <meta name="description" content="PHP之十六个魔术方法详解这是摘抄的，不过很好懂对于初级程序员来说可以读一下">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP之十六个魔术方法详解">
<meta property="og:url" content="http://zoulp.github.io/2016/10/25/phpMagic/index.html">
<meta property="og:site_name" content="Lpeng Zou">
<meta property="og:description" content="PHP之十六个魔术方法详解这是摘抄的，不过很好懂对于初级程序员来说可以读一下">
<meta property="og:updated_time" content="2016-10-25T10:08:22.033Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHP之十六个魔术方法详解">
<meta name="twitter:description" content="PHP之十六个魔术方法详解这是摘抄的，不过很好懂对于初级程序员来说可以读一下">

    
    <link rel="alternative" href="/atom.xml" title="Lpeng Zou" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Lpeng Zou" title="Lpeng Zou"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Lpeng Zou">Lpeng Zou</a></h1>
				<h2 class="blog-motto">kevin_zo@sina</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">about</a></li>
					
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/25/phpMagic/" title="PHP之十六个魔术方法详解" itemprop="url">PHP之十六个魔术方法详解</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lpeng Zou" target="_blank" itemprop="author">Lpeng Zou</a>
		
  <p class="article-time">
    <time datetime="2016-10-25T09:02:07.000Z" itemprop="datePublished"> 发表于 2016-10-25</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#construct-，类的构造函数"><span class="toc-number">1.</span> <span class="toc-text">__construct()，类的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#destruct-，类的析构函数"><span class="toc-number">2.</span> <span class="toc-text">__destruct()，类的析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-，在对象中调用一个不可访问方法时调用。"><span class="toc-number">3.</span> <span class="toc-text">__call()，在对象中调用一个不可访问方法时调用。</span></a></li></ol>
		
		</div>
		
		<p><em>PHP之十六个魔术方法详解</em><br><em>这是摘抄的，不过很好懂</em><br><em>对于初级程序员来说可以读一下</em><br><a id="more"></a><br><a href="https://segmentfault.com/a/1190000007250604" target="_blank" rel="external">点击原文：PHP之十六个魔术方法详解</a></p>
<ul>
<li><strong> Magic methods </strong><br>PHP中把以两个下划线__开头的方法称为魔术方法(Magic methods)，<br>这些方法在PHP中充当了举足轻重的作用。<br>魔术方法包括：</li>
</ul>
<blockquote>
<p><strong>construct()，类的构造函数
</strong>destruct()，类的析构函数<br><strong>call()，在对象中调用一个不可访问方法时调用
</strong>callStatic()，用静态方式中调用一个不可访问方法时调用<br><strong>get()，获得一个类的成员变量时调用
</strong>set()，设置一个类的成员变量时调用<br><strong>isset()，当对不可访问属性调用isset()或empty()时调用
</strong>unset()，当对不可访问属性调用unset()时被调用。<br><strong>sleep()，执行serialize()时，先会调用这个函数
</strong>wakeup()，执行unserialize()时，先会调用这个函数<br><strong>toString()，类被当成字符串时的回应方法
</strong>invoke()，调用函数的方式调用一个对象时的回应方法<br><strong>set_state()，调用var_export()导出类时，此静态方法会被调用。
</strong>clone()，当对象复制完成时调用<br><strong>autoload()，尝试加载未定义的类
</strong>debugInfo()，打印所需调试信息</p>
</blockquote>
<p>范例<br>下面让我们以实例的形式向大家讲解下这几个魔术方法时如何使用的。</p>
<h2 id="construct-，类的构造函数"><a href="#construct-，类的构造函数" class="headerlink" title="__construct()，类的构造函数"></a>__construct()，类的构造函数</h2><p>php中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。</p>
<p>1、 构造方法的作用</p>
<p>通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。</p>
<p>2、 构造方法的在类中的声明格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function __constrct([参数列表])&#123;</div><div class="line"></div><div class="line">    方法体 //通常用来对成员属性进行初始化赋值</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、 在类中声明构造方法需要注意的事项</p>
<pre><code>*1)在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。*

*2)构造方法名称是以两个下画线开始的__construct()*
</code></pre><p>下面是它的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    class Person</div><div class="line">    &#123;                                                                      </div><div class="line">            public $name;        </div><div class="line">            public $age;        </div><div class="line">            public $sex;        </div><div class="line">                                                                 </div><div class="line">        /**</div><div class="line">         * 显示声明一个构造方法且带参数</div><div class="line">         */                                                                                       </div><div class="line">        public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</div><div class="line">        &#123;      </div><div class="line">            $this-&gt;name = $name;</div><div class="line">            $this-&gt;sex = $sex;</div><div class="line">            $this-&gt;age = $age;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        /**</div><div class="line">         * say 方法</div><div class="line">         */</div><div class="line">        public function say()</div><div class="line">        &#123; </div><div class="line">            echo &quot;我叫：&quot; . $this-&gt;name . &quot;，性别：&quot; . $this-&gt;sex . &quot;，年龄：&quot; . $this-&gt;age;</div><div class="line">        &#125;   </div><div class="line">                                                                                           </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">创建对象$Person1且不带任参数</div><div class="line">$Person1 = new Person();</div><div class="line">echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27</div><div class="line">创建对象$Person2且带参数“小明”</div><div class="line"></div><div class="line">$Person2 = new Person(&quot;小明&quot;);</div><div class="line">echo $Person2-&gt;say(); //输出：我叫：张三，性别：男，年龄：27</div><div class="line">创建对象$Person3且带三个参数</div><div class="line"></div><div class="line">$Person3 = new Person(&quot;李四&quot;,&quot;男&quot;,25);</div><div class="line">echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25</div></pre></td></tr></table></figure>
<h2 id="destruct-，类的析构函数"><a href="#destruct-，类的析构函数" class="headerlink" title="__destruct()，类的析构函数"></a>__destruct()，类的析构函数</h2><p>通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。</p>
<p>析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。</p>
<p>析构方法是PHP5才引进的新内容。</p>
<p>析造方法的声明格式与构造方法 <strong>construct() 比较类似，也是以两个下划线开始的方法 </strong>destruct() ，这种析构方法名称也是固定的。</p>
<p>1、 析构方法的声明格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function __destruct()</div><div class="line">&#123;</div><div class="line"> //方法体</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：析构函数不能带有任何参数。</p>
<p>2、 析构方法的作用</p>
<p>一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。<br>举例演示，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person&#123;     </div><div class="line">                                                        </div><div class="line">    public $name;         </div><div class="line">    public $age;         </div><div class="line">    public $sex;         </div><div class="line">                                                                    </div><div class="line">    public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</div><div class="line">    &#123;   </div><div class="line">        $this-&gt;name = $name;</div><div class="line">        $this-&gt;sex  = $sex;</div><div class="line">        $this-&gt;age  = $age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * say 说话方法</div><div class="line">     */</div><div class="line">    public function say()</div><div class="line">    &#123;  </div><div class="line">        echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age;</div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 声明一个析构方法</div><div class="line">     */</div><div class="line">    public function __destruct()</div><div class="line">    &#123;</div><div class="line">            echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$Person = new Person(&quot;小明&quot;);</div><div class="line">unset($Person); //销毁上面创建的对象$Person</div></pre></td></tr></table></figure></p>
<p>上面的程序运行时输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我觉得我还可以再抢救一下，我的名字叫小明</div></pre></td></tr></table></figure></p>
<h2 id="call-，在对象中调用一个不可访问方法时调用。"><a href="#call-，在对象中调用一个不可访问方法时调用。" class="headerlink" title="__call()，在对象中调用一个不可访问方法时调用。"></a>__call()，在对象中调用一个不可访问方法时调用。</h2><p>该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。</p>
<p>1、 __call() 方法的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function __call(string $function_name, array $arguments)</div><div class="line">&#123;</div><div class="line">    // 方法体</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、 __call() 方法的作用：</p>
<p>为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。</p>
<p>该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。<br>请参考如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">class Person</div><div class="line">&#123;                             </div><div class="line">    function say()</div><div class="line">    &#123;  </div><div class="line">                              </div><div class="line">           echo &quot;Hello, world!&lt;br&gt;&quot;; </div><div class="line">    &#125;      </div><div class="line">        </div><div class="line">    /**</div><div class="line">     * 声明此方法用来处理调用对象中不存在的方法</div><div class="line">     */</div><div class="line">    function __call($funName, $arguments)</div><div class="line">    &#123; </div><div class="line">          echo &quot;你所调用的函数：&quot; . $funName . &quot;(参数：&quot; ;  // 输出调用不存在的方法名</div><div class="line">          print_r($arguments); // 输出调用不存在的方法时的参数列表</div><div class="line">          echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行                      </div><div class="line">    &#125;                                          </div><div class="line">&#125;</div><div class="line">$Person = new Person();            </div><div class="line">$Person-&gt;run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法</div><div class="line">$Person-&gt;eat(&quot;小明&quot;, &quot;苹果&quot;);             </div><div class="line">$Person-&gt;say();        </div><div class="line">```                </div><div class="line">&gt; 运行结果：</div></pre></td></tr></table></figure></p>
<p>你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！</p>
<p>你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！</p>
<p>Hello, world!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">##   __callStatic()，用静态方式中调用一个不可访问方法时调用</div><div class="line">此方法与上面所说的 __call() 功能除了 __callStatic() 是未静态方法准备的之外，其它都是一样的。</div><div class="line"></div><div class="line">请看下面代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    function say()<br>    {</p>
<pre><code>    echo &quot;Hello, world!&lt;br&gt;&quot;;
}

/**
 * 声明此方法用来处理调用对象中不存在的方法
 */
public static function __callStatic($funName, $arguments)
{
    echo &quot;你所调用的静态方法：&quot; . $funName . &quot;(参数：&quot; ;  // 输出调用不存在的方法名
    print_r($arguments); // 输出调用不存在的方法时的参数列表
    echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行
}
</code></pre><p>}<br>$Person = new Person();<br>$Person::run(“teacher”); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法<br>$Person::eat(“小明”, “苹果”);<br>$Person-&gt;say();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">运行结果如下：</div></pre></td></tr></table></figure></p>
<p>你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！<br>你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！<br>Hello, world!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">##   __get()，获得一个类的成员变量时调用</div><div class="line">在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。</div><div class="line"></div><div class="line">魔术方法__get()的作用</div><div class="line">在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。</div><div class="line">我们通过下面的 __get() 的实例来更进一步的连接它吧：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    private $name;<br>    private $age;</p>
<pre><code>function __construct($name=&quot;&quot;, $age=1)
{
    $this-&gt;name = $name;
    $this-&gt;age = $age;
}

/**
 * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理
 * @param $propertyName
 *
 * @return int
 */
public function __get($propertyName)
{   
    if ($propertyName == &quot;age&quot;) {
        if ($this-&gt;age &gt; 30) {
            return $this-&gt;age - 10;
        } else {
            return $this-&gt;$propertyName;
        }
    } else {
        return $this-&gt;$propertyName;
    }
}
</code></pre><p>}<br>$Person = new Person(“小明”, 60);   // 通过Person类实例化的对象，并通过构造方法为属性赋初值<br>echo “姓名：” . $Person-&gt;name . “<br>“;   // 直接访问私有属性name，自动调用了<strong>get()方法可以间接获取<br>echo “年龄：” . $Person-&gt;age . “<br>“;    // 自动调用了</strong>get()方法，根据对象本身的情况会返回不同的值</p>
<blockquote>
<p>运行结果：</p>
</blockquote>
<p>姓名：小明<br>年龄：50<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">##  __set()，设置一个类的成员变量时调用</div><div class="line">__set() 的作用：</div><div class="line">__set( $property, $value )，方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。</div><div class="line"></div><div class="line">请看下面的演示代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    private $name;<br>    private $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
}

/**
 * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值
 * @param $property
 * @param $value
 */
public function __set($property, $value) {
    if ($property==&quot;age&quot;)
    {
        if ($value &gt; 150 || $value &lt; 0) {
            return;
        }
    }
    $this-&gt;$property = $value;
}

/**
 * 在类中声明说话的方法，将所有的私有属性说出
 */
public function say(){
    echo &quot;我叫&quot;.$this-&gt;name.&quot;，今年&quot;.$this-&gt;age.&quot;岁了&quot;;
}
</code></pre><p>}</p>
<p>$Person=new Person(“小明”, 25); //注意，初始值将被下面所改变<br>//自动调用了<strong>set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数<br>$Person-&gt;name = “小红”;     //赋值成功。如果没有</strong>set()，则出错。<br>//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数<br>$Person-&gt;age = 16; //赋值成功<br>$Person-&gt;age = 160; //160是一个非法值，赋值失效<br>$Person-&gt;say();  //输出：我叫小红，今年16岁了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 运行结果：</div></pre></td></tr></table></figure></p>
<p>我叫小红，今年16岁了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">##  __isset()，当对不可访问属性调用isset()或empty()时调用</div><div class="line">在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。</div><div class="line"></div><div class="line">那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？</div><div class="line"></div><div class="line">分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个__isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的__isset()方法了帮我们完成这样的操作。</div><div class="line"></div><div class="line">__isset()的作用：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。</div><div class="line">请看下面代码演示：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    private $name;<br>    private $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}

/**
 * @param $content
 *
 * @return bool
 */
public function __isset($content) {
    echo &quot;当在类外部使用isset()函数测定私有成员{$content}时，自动调用&lt;br&gt;&quot;;
    echo  isset($this-&gt;$content);
}
</code></pre><p>}</p>
<p>$person = new Person(“小明”, 25); // 初始赋值<br>echo isset($person-&gt;sex),”<br>“;<br>echo isset($person-&gt;name),”<br>“;<br>echo isset($person-&gt;age),”<br>“;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">运行结果如下：</div></pre></td></tr></table></figure></p>
<p>// public 可以 isset()<br>当在类外部使用isset()函数测定私有成员name时，自动调用 // <strong>isset() 内 第一个echo<br>// </strong>isset() 内第二个echo<br>当在类外部使用isset()函数测定私有成员age时，自动调用 // <strong>isset() 内 第一个echo<br>// </strong>isset() 内第二个echo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">##   __unset()，当对不可访问属性调用unset()时被调用。</div><div class="line">看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。</div><div class="line"></div><div class="line">那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？</div><div class="line"></div><div class="line">这里自然也是分两种情况：</div><div class="line"></div><div class="line">1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。</div><div class="line"></div><div class="line">2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。</div><div class="line"></div><div class="line">虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上__unset()</div><div class="line">这个方法，就可以在对象的外部去删除对象的私有成员属性了。</div><div class="line">在对象里面加上了__unset()这个方法之后，</div><div class="line">在对象外部使用“unset()”函数删除对象内部的私有成员属性时，</div><div class="line">对象会自动调用__unset()函数来帮我们删除对象内部的私有成员属性。</div><div class="line"></div><div class="line">请看如下代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    private $name;<br>    private $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}

/**
 * @param $content
 *
 * @return bool
 */
public function __unset($content) {
    echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;;
    echo  isset($this-&gt;$content);
}
</code></pre><p>}</p>
<p>$person = new Person(“小明”, 25); // 初始赋值<br>unset($person-&gt;sex);<br>unset($person-&gt;name);<br>unset($person-&gt;age);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 运行结果：</div></pre></td></tr></table></figure></p>
<p>当在类外部使用unset()函数来删除私有成员时自动调用的<br>当在类外部使用unset()函数来删除私有成员时自动调用的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">##  __sleep()，执行serialize()时，先会调用这个函数</div><div class="line">serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。</div><div class="line"></div><div class="line">此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</div><div class="line"></div><div class="line">如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。</div><div class="line"></div><div class="line">注意：</div><div class="line"></div><div class="line">__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。</div><div class="line">作用：</div><div class="line"></div><div class="line">__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。</div><div class="line">具体请参考如下代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    public $name;<br>    public $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}

/**
 * @return array
 */
public function __sleep() {
    echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;
    $this-&gt;name = base64_encode($this-&gt;name);
    return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称
}
</code></pre><p>}</p>
<p>$person = new Person(‘小明’); // 初始赋值<br>echo serialize($person);<br>echo ‘<br>‘;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">代码&gt; 运行结果：</div></pre></td></tr></table></figure></p>
<p>当在类外部使用serialize()时会调用这里的__sleep()方法<br>O:6:”Person”:2:{s:4:”name”;s:8:”5bCP5piO”;s:3:”age”;i:25;}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">十、 __wakeup()，执行unserialize()时，先会调用这个函数</div><div class="line">如果说 __sleep() 是白的，那么 __wakeup() 就是黑的了。</div><div class="line"></div><div class="line">那么为什么呢？</div><div class="line"></div><div class="line">因为：</div><div class="line"></div><div class="line">与之相反，`unserialize()` 会检查是否存在一个 `__wakeup()` 方法。如果存在，则会先调用 `__wakeup` 方法，预先准备对象需要的资源。</div><div class="line">作用：</div><div class="line"></div><div class="line"></div><div class="line">__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。</div><div class="line">还是看代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    public $name;<br>    public $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}

/**
 * @return array
 */
public function __sleep() {
    echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;
    $this-&gt;name = base64_encode($this-&gt;name);
    return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称
}

/**
 * __wakeup
 */
public function __wakeup() {
    echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;;
    $this-&gt;name = 2;
    $this-&gt;sex = &apos;男&apos;;
    // 这里不需要返回数组
}
</code></pre><p>}</p>
<p>$person = new Person(‘小明’); // 初始赋值<br>var_dump(serialize($person));<br>var_dump(unserialize(serialize($person)));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 运行结果：</div></pre></td></tr></table></figure></p>
<p>当在类外部使用serialize()时会调用这里的<strong>sleep()方法<br>string(58) “O:6:”Person”:2:{s:4:”name”;s:8:”5bCP5piO”;s:3:”age”;i:25;}” 当在类外部使用serialize()<br>时会调用这里的</strong>sleep()方法<br>当在类外部使用unserialize()时会调用这里的__wakeup()方法<br>object(Person)#2 (3) { [“sex”]=&gt; string(3) “男” [“name”]=&gt; int(2) [“age”]=&gt; int(25) }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">##    __toString()，类被当成字符串时的回应方法</div><div class="line">作用：</div><div class="line"></div><div class="line">__toString() 方法用于一个类被当成字符串时应怎样回应。例如 `echo $obj;` 应该显示些什么。</div><div class="line">注意：</div><div class="line">此方法必须返回一个字符串，否则将发出一条 `E_RECOVERABLE_ERROR` 级别的致命错误。</div><div class="line">警告：</div><div class="line">不能在 __toString() 方法中抛出异常。这么做会导致致命错误。</div><div class="line">代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    public $name;<br>    public $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}

public function __toString()
{
    return  &apos;go go go&apos;;
}
</code></pre><p>}<br>$person = new Person(‘小明’); // 初始赋值<br>echo $person;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">结果：</div><div class="line"></div><div class="line">go go go</div><div class="line">那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下：</div><div class="line"></div><div class="line">代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    public $name;<br>    public $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}
</code></pre><p>}</p>
<p>$person = new Person(‘小明’); // 初始赋值<br>echo $person;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">结果：</div></pre></td></tr></table></figure></p>
<p>Catchable fatal error: Object of class Person could not be converted to string in D:\phpStudy\WWW\test\index.php on line 18<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">很明显，页面报了一个致命错误，这是语法所不允许的。</div><div class="line"></div><div class="line">##    __invoke()，调用函数的方式调用一个对象时的回应方法</div><div class="line">作用：</div><div class="line"></div><div class="line">当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。</div><div class="line">注意：</div><div class="line"></div><div class="line">本特性只在 PHP 5.3.0 及以上版本有效。</div><div class="line">直接上代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    public $name;<br>    public $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}

public function __invoke() {
    echo &apos;这可是一个对象哦&apos;;
}
</code></pre><p>}</p>
<p>$person = new Person(‘小明’); // 初始赋值<br>$person();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">查看&gt; 运行结果：</div><div class="line"></div><div class="line">这可是一个对象哦</div><div class="line">当然，如果你执意要将对象当函数方法使用，那么会得到下面结果：</div></pre></td></tr></table></figure></p>
<p>Fatal error: Function name must be a string in D:\phpStudy\WWW\test\index.php on line 18<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">##    __set_state()，调用var_export()导出类时，此静态方法会被调用。</div><div class="line">作用：</div><div class="line"></div><div class="line">自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。</div><div class="line">参数：</div><div class="line"></div><div class="line">本方法的唯一参数是一个数组，其中包含按 array(&apos;property&apos; =&gt; value, ...) 格式排列的类属性。</div><div class="line">下面我们先来看看在没有加 __set_state() 情况按下，代码及运行结果如何：</div><div class="line"></div><div class="line">上代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    public $name;<br>    public $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}
</code></pre><p>}<br>$person = new Person(‘小明’); // 初始赋值<br>var_export($person);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">看结果：</div></pre></td></tr></table></figure></p>
<p>Person::__set_state(array( ‘sex’ =&gt; ‘男’, ‘name’ =&gt; ‘小明’, ‘age’ =&gt; 25, ))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">很明显，将对象中的属性都打印出来了</div><div class="line">加了 __set_state() 之后：</div><div class="line">继续上代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    public $name;<br>    public $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}

public static function __set_state($an_array)
{
    $a = new Person();
    $a-&gt;name = $an_array[&apos;name&apos;];
    return $a;
}
</code></pre><p>}</p>
<p>$person = new Person(‘小明’); // 初始赋值<br>$person-&gt;name = ‘小红’;<br>var_export($person);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">继续看结果：</div></pre></td></tr></table></figure></p>
<p>Person::__set_state(array( ‘sex’ =&gt; ‘男’, ‘name’ =&gt; ‘小红’, ‘age’ =&gt; 25, ))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">##    __clone()，当对象复制完成时调用</div><div class="line">在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。</div><div class="line"></div><div class="line">作用：</div><div class="line"></div><div class="line">对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。</div><div class="line">语法：</div><div class="line"></div><div class="line">$copy_of_object = clone $object;</div><div class="line">注意：</div><div class="line"></div><div class="line">当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。</div><div class="line"></div><div class="line">当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。</div><div class="line">看代码：</div></pre></td></tr></table></figure></p>
<p>&lt;?php<br>class Person<br>{<br>    public $sex;<br>    public $name;<br>    public $age;</p>
<pre><code>public function __construct($name=&quot;&quot;,  $age=25, $sex=&apos;男&apos;)
{
    $this-&gt;name = $name;
    $this-&gt;age  = $age;
    $this-&gt;sex  = $sex;
}

public function __clone()
{
    echo __METHOD__.&quot;你正在克隆对象&lt;br&gt;&quot;;
}
</code></pre><p>}</p>
<p>$person = new Person(‘小明’); // 初始赋值<br>$person2 = clone $person;</p>
<p>var_dump(‘persion1:’);<br>var_dump($person);<br>echo ‘<br>‘;<br>var_dump(‘persion2:’);<br>var_dump($person2);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">看结果：</div></pre></td></tr></table></figure></p>
<p>Person::__clone你正在克隆对象<br>string(9) “persion1:” object(Person)#1 (3) { [“sex”]=&gt; string(3) “男” [“name”]=&gt; string(6) “小明” [“age”]=&gt; int(25) }<br>string(9) “persion2:” object(Person)#2 (3) { [“sex”]=&gt; string(3) “男” [“name”]=&gt; string(6) “小明” [“age”]=&gt; int(25) }<br>克隆成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">##   __autoload()，尝试加载未定义的类</div><div class="line">作用：</div><div class="line"></div><div class="line">你可以通过定义这个函数来启用类的自动加载。</div><div class="line">在魔术函数 __autoload() 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。</div><div class="line"></div><div class="line">但是有了 __autoload() 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。</div><div class="line"></div><div class="line">还是通过例子来看看吧：</div><div class="line"></div><div class="line">先看看以往的方式：</div></pre></td></tr></table></figure></p>
<p>/** </p>
<ul>
<li>文件non_autoload.php<br>*/ </li>
</ul>
<p>require_once(‘project/class/A.php’);<br>require_once(‘project/class/B.php’);<br>require_once(‘project/class/C.php’);  </p>
<p>if (条件A) {<br>    $a = new A();<br>    $b = new B();<br>    $c = new C();<br>    // … 业务逻辑<br>} else if (条件B) {<br>    $a = newA();<br>    $b = new B();<br>    // … 业务逻辑<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。</div><div class="line"></div><div class="line">那么如果使用 __autoload() 方式呢？</div></pre></td></tr></table></figure></p>
<p>/** </p>
<ul>
<li>文件autoload_demo.php<br>*/<br>function  __autoload($className) {<br> $filePath = “project/class/{$className}.php”;<br> if (is_readable($filePath)) {  <pre><code>require($filePath);  
</code></pre> }<br>}  </li>
</ul>
<p>if (条件A) {<br>    $a = new A();<br>    $b = new B();<br>    $c = new C();<br>    // … 业务逻辑<br>} else if (条件B) {<br>    $a = newA();<br>    $b = new B();<br>    // … 业务逻辑<br>}<br>```<br>ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。</p>
<p>再来看看这里的效率如何，我们分析下：</p>
<p>当php引擎第一次使用类A，但是找不到时，会自动调用 <strong>autoload 方法，并将类名“A”作为参数传入。所以，我们在 </strong>autoload() 中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。</p>
<p>注意：</p>
<p>这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，将不会调用__autoload，<br>而是直接使用内存中的类A，不会导致多次包含。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/php/">php</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/php/">php</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://zoulp.github.io/2016/10/25/phpMagic/" data-title="PHP之十六个魔术方法详解 | Lpeng Zou" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/10/24/jsReg/"  title="js正则用法详解">
 <strong>下一篇：</strong><br/> 
 <span>js正则用法详解
</span>
</a>
</div>

</nav>

	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#construct-，类的构造函数"><span class="toc-number">1.</span> <span class="toc-text">__construct()，类的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#destruct-，类的析构函数"><span class="toc-number">2.</span> <span class="toc-text">__destruct()，类的析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-，在对象中调用一个不可访问方法时调用。"><span class="toc-number">3.</span> <span class="toc-text">__call()，在对象中调用一个不可访问方法时调用。</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/mysql/" title="mysql">mysql<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/other/" title="other">other<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/php/" title="php">php<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/redis/" title="redis">redis<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/web/" title="web">web<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/web/" title="web">web<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/other/" title="other">other<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/php/" title="php">php<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/http/" title="http">http<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/css/" title="css">css<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/session/" title="session">session<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/redis/" title="redis">redis<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/vim/" title="vim">vim<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://zoulp.github.io" target="_blank" title="Lpeng Zou&#39;s Blog">Lpeng Zou&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 回头看看自己的路.我已竭尽全力 <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/http://weibo.com/p/1005055982977300" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="Lpeng Zou">Lpeng Zou</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
